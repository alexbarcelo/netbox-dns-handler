"""NetBox DNS Handler (NBdnsH) script.

This will syncronize information available in NetBox into a PowerDNS database.
"""
import os
import sqlite3
from ipaddress import ip_interface

import pynetbox

from dbhandler.pdns import PdnsDBHandler


# Environment variables that are required
NETBOX_TOKEN = os.environ["NETBOX_TOKEN"]
NETBOX_API = os.environ["NETBOX_API"]
DNS_SQLITE3_FILE = os.environ["NBDNSH_SQLITE3_FILE"]

# NetBox connection
nb = pynetbox.api(
    NETBOX_API, token=NETBOX_TOKEN
)

# This could be hardcoded to the appropriate integer
AUTOGENERATED_TAG = nb.extras.tags.get(slug="autogenerated").id

DNS_ROOT_DOMAIN = 'betarho.lan'

IPV6PREFIX =  "2600:70ff:f0de::"


def _mac_to_ipv6(ipv6_prefix, iface_mac, mask=64):
    mac_parts = iface_mac.split(":")

    # Insert the ff:fe in the middle
    mac_parts.insert(3, "ff")
    mac_parts.insert(4, "fe")

    # Toggle the appropriate bit
    mac_parts[0] = "%x" % (int(mac_parts[0], 16) ^ 2)

    # Join mac parts into IPv6 parts
    ipv6_parts = []
    for i in range(0, len(mac_parts), 2):
        ipv6_parts.append("".join(mac_parts[i:i+2]))

    # Final (hopefully)valid IPv6 string
    return ip_interface(f"{ ipv6_prefix }{ ':'.join(ipv6_parts) }/{ mask }")


def _manage_ips_for_iface(iface, autogen_ips, iface_type):
    generated_ip = _mac_to_ipv6(IPV6PREFIX, iface.mac_address)

    try:
        base_obj = iface.virtual_machine
    except AttributeError:
        base_obj = iface.device

    fqdn = f'{ str(base_obj).lower().replace(" ", "_") }.{ DNS_ROOT_DOMAIN }'    
    found = False

    for ip in autogen_ips:
        ipiface = ip_interface(ip.address)
        if ipiface != generated_ip or ip.dns_name != fqdn:
            print(f"I wanted to remove the IP { ip.dns_name }@{ ipiface } "
                  f"because it does not match the one I generated: { fqdn }@{ generated_ip }")
            print(ip.url)
        else:
            print(f"The IP { ipiface } is already a valid autogenerated IPv6 address for the configured prefix")
            found = True

    if not found:
        print(f"Creating and assigning IP { generated_ip } for FQDN { fqdn }")
        nb.ipam.ip_addresses.create(
            address=generated_ip.with_prefixlen, 
            assigned_object_id=iface.id,
            assigned_object_type=iface_type,
            dns_name=fqdn,
            tags=[AUTOGENERATED_TAG])


def populate_ipv6_addresses():
    interfaces = nb.dcim.interfaces.filter(tag="ipv6_hwaddr")

    for iface in interfaces:
        autoassigned_ips = nb.ipam.ip_addresses.filter(interface_id=iface.id, tag="autogenerated", status="active")

        _manage_ips_for_iface(iface, autoassigned_ips, "dcim.interface")


def populate_ipv6_addresses_vm():
    interfaces = nb.virtualization.interfaces.filter(tag="ipv6_hwaddr")

    for iface in interfaces:
        autoassigned_ips = nb.ipam.ip_addresses.filter(vminterface_id=iface.id, tag="autogenerated", status="active")

        _manage_ips_for_iface(iface, autoassigned_ips, "virtualization.vminterface")


def main():
    # First populate the IPv6 addresses of both Virtual Machines and general devices
    populate_ipv6_addresses_vm()
    populate_ipv6_addresses()

    dbhandler = PdnsDBHandler(DNS_SQLITE3_FILE, DNS_ROOT_DOMAIN)

    # TODO: why the dns_name__n="" is not working? I expected that to match non-empty dns_name entries
    nb_data = nb.ipam.ip_addresses.filter(status="active", dns_name__n="")
    dbhandler.populate_ips(nb_data)

    nb_data = nb.ipam.services.filter(tag="node-exporter")
    dbhandler.populate_srv(nb_data, "node_exporter.betarho.lan")
    
    all_entries = set()
    for entry in nb.ipam.ip_addresses.filter(status="active"):
        all_entries.add((ip_interface(entry.address).ip, entry.dns_name))    
    # This is a slow operation. Maybe it should be done less often
    dbhandler.cleanup_addresses(all_entries)


if __name__ == "__main__":
    main()
